// Welcome to Scala

// One of the nice features in Scala is support for *generic types*.

// A generic type is a type whose definition depends on another type. A typical example to keep in mind is the List constructor. We can have lists of strings, lists of integers, lists of Booleans, etc.; all these are different types, but operations like concat and append are defined the same way for all of them.

// To define a new list in Scala, use the List constructor. It will examine the types of the entities you enter, and infer the type of the list from that:

val intList = List(1,2,3)

var strList = List("one","two","three")

// If you mix types in a list, the type associated with the list will be weakened to a common supertype, similar to what happened with mixed if...then statement:

var mixedList = List("one",2,false)


// Some list operations are type specific. For example, we can sum a list of integers, but not a list of strings:

intList.sum


strList.sum

// In order to specify the type of a list, write it inside square brackets. We can also use this to weaken the typing on a list.

val l : List[Int] = List(1,2,3)

val ll = List[Any](1,2,3)

//=====================================

// Imperative vs. Declarative programming

// Imperative programming tells the computer what to do. It is considered bad style in Scala because it requires mutable data types & modifies state.

// Here's an example of imperative style. Notice that we have to use a special mutable list type rather than the default constructor included in Scala's standard library:

val lm = scala.collection.mutable.MutableList(2,3,4,5)

var i = 0
while (i < lm.length) {
  val n = lm(i)
  println(n*n)
  i = i + 1
}

// Declarative: Tell the computer what things are

// Notice that below i represents a list element directly, whereas above it represents the index of a list element.


val lss = List(2,3,4,5)

for(n <- lss) {   // Read "for i in lss ..."
  println(n*n)
}

//==========================================

// List operations

// There are a wide variety of special-purpose operations defined on all lists. The most important ones are listed below. Notice, in particular, the extensive use of callback functions (per lesson 3).

// Get list elements by index (starting at 0)

val li = List(1,2,3,4,5,6)

li(2)

li(4)

// If we try an index that is too large, we get a run-time error:

li(7)


// Concatenation of two lists

List(1,2,3) ++ List(4,5,6)

// Prepend an element to the front of a list

1 :: List(2,3,4)

// Slice: Select a sublist

List(1,2,3,4,5,6,7,8).slice(2,5)

// Map: Given as : List[A] and a function f:A => B, this returns the list of B's generated by applying f to each element of as, one by one:

val strs = List("one","two","three","four")
def len(s : String) = s.length

strs.map(len)

// Rather than writing special-purpose functions like len, we can use either of the following *anonymous function* notations:

strs.map(s => s.length)

strs.map(_.length)

// Flatten: Flatten lets us take a list of lists and smash it into a single list by remove the internal parentheses:

val listOfLists = List(
  List(1,2,3,4),
  List(5,6),
  List(7,8,9)
)

listOfLists.flatten

// flatMap combines map and flatten into one operation:

def stringChars(s : String) : List[Char] = s.toList


stringChars("Hello")

val listOfCharLists = List("Hello","world").map(stringChars)

listOfCharLists.flatten

List("Hello","world").flatMap(stringChars)


// Filter: Given a list l : List[A] and a filtering function A => Boolean, returns the sublist of all elements satisfying the filter:

val evens = List(1,2,3,4,5,6,7,8,9,10).filter(n => n % 2 == 0)

// Reduce: Aggregates elements of the list using a given binary operation:

List(1,2,3,4,5).reduce((x,y) => x+y)

List(1,2,3,4,5).reduce(_ + _)

List("A","list","of","words").reduce(_ + " " + _)

// Fold: Like reduce, but it also takes an additional value to initialize the aggregation:

List("A","list","of","words").fold("!!")(_ + " " + _)

// Zip: Combines two list into a list of Cartesian pairs. If one list is longer than the other, the extra elements are discarded:

List("one","two","three").zip(List(1,2,3,4))

// Zipwithindex : Does what it says:

List("one","two","three").zipWithIndex